// This file is part of the CircuitPython project: https://circuitpython.org
//
// SPDX-FileCopyrightText: Copyright (c) 2025 Lucian Copeland
//
// SPDX-License-Identifier: MIT

#include "shared-bindings/rclcpy/Publisher.h"
#include "shared-bindings/rclcpy/registry.h"

#include "esp_log.h"

void common_hal_rclcpy_publisher_construct(rclcpy_publisher_obj_t *self, rclcpy_node_obj_t *node,
    const mp_obj_type_t *message_type, const char *topic_name) {

    const rosidl_message_type_support_t *type_support = common_hal_rclcpy_registry_get_msg_ros_typesupport(message_type);
    if (!type_support) {
        mp_raise_ValueError(MP_ERROR_TEXT("Invalid ROS message type"));
    }

    // Creates a reliable Int32 publisher
    rcl_ret_t rc = rclc_publisher_init_default(
        &self->rcl_publisher, &node->rcl_node,
        type_support, topic_name);
    if (RCL_RET_OK != rc) {
        mp_raise_RuntimeError(MP_ERROR_TEXT("ROS topic failed to initialize"));
    }

    self->node = node;
    self->message_type = message_type;
}

bool common_hal_rclcpy_publisher_deinited(rclcpy_publisher_obj_t *self) {
    return self->node == NULL;
}

void common_hal_rclcpy_publisher_deinit(rclcpy_publisher_obj_t *self) {
    if (common_hal_rclcpy_publisher_deinited(self)) {
        return;
    }
    // Clean up Micro-ROS object
    rcl_ret_t ret = rcl_publisher_fini(&self->rcl_publisher, &self->node->rcl_node);
    if (ret != RCL_RET_OK) {
        // TODO: publisher_fini returns a fail here, but doesn't impede microros
        // from restarting. Debug left for future investigation.
        ESP_LOGW("RCLCPY", "Publisher cleanup error: %d", ret);
        // rclcpy_default_context.critical_fail=RCLCPY_PUB_FAIL;
    }
    self->node = NULL;
}

void common_hal_rclcpy_publisher_publish(rclcpy_publisher_obj_t *self, mp_obj_t message_obj) {

    const rclcpy_registry_msg_entry_t *entry = common_hal_rclcpy_registry_get_msg_entry(self->message_type);
    if (!entry) {
        mp_raise_ValueError(MP_ERROR_TEXT("Invalid message type"));
    }

    rcl_ret_t rc = RCL_RET_ERROR;

    // This will eventually be moved to an autogenerated dispatcher file.
    switch (entry->msg_kind) {
        case RCLCPY_MSG_TYPE_BOOL: {
            rclcpy_std_msgs_bool_obj_t *bool_msg = MP_OBJ_TO_PTR(message_obj);
            std_msgs__msg__Bool ros_msg;
            ros_msg.data = bool_msg->data;
            rc = rcl_publish(&self->rcl_publisher, &ros_msg, NULL);
            break;
        }
        case RCLCPY_MSG_TYPE_INT32: {
            rclcpy_std_msgs_int32_obj_t *int32_msg = MP_OBJ_TO_PTR(message_obj);
            std_msgs__msg__Int32 ros_msg;
            ros_msg.data = int32_msg->data;
            rc = rcl_publish(&self->rcl_publisher, &ros_msg, NULL);
            break;
        }
        default:
            mp_raise_ValueError(MP_ERROR_TEXT("Unsupported message type"));
            return;
    }

    if (RCL_RET_OK != rc) {
        mp_raise_RuntimeError(MP_ERROR_TEXT("Could not publish to ROS topic"));
    }
}

const char *common_hal_rclcpy_publisher_get_topic_name(rclcpy_publisher_obj_t *self) {
    return rcl_publisher_get_topic_name(&self->rcl_publisher);
}
